# nsd2002-py02-day02

[TOC]

## 函数

- 定义函数的先后顺序不重要，重要的是调用顺序

- 函数调用时，传递的参数，写为key=val形式，称作关键字参数；直接写为arg，称作位置参数

```python
>>> def func1(name, age):
...   print('%s is %s years old' % (name, age))
... 
>>> func1('tom', 20)   # OK
tom is 20 years old
>>> func1(20, 'tom')   # 语法正确，语义不对
20 is tom years old
>>> func1(age=20, name='tom')  # OK
tom is 20 years old
>>> func1(age=20, 'tom')  # 语法错误，只能位置参数在前，关键字参数在后
  File "<stdin>", line 1
SyntaxError: positional argument follows keyword argument
>>> func1(20, name='tom')   # Error，name得到了多个值
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: func1() got multiple values for argument 'name'
>>> func1('tom', age=20)  # OK
tom is 20 years old
```

- 定义函数时，如果将函数的参数前加`*`，表示使用元组接收参数
- 定义函数时，如果将函数的参数前加`**`，表示使用字典接收参数

```python
>>> def func1(*args):
...   print(args)
... 
>>> func1()
()
>>> func1('hao')
('hao',)
>>> func1('hao', 123)
('hao', 123)
>>> func1('hao', 123, 'tom', 'jerry')
('hao', 123, 'tom', 'jerry')

>>> def func2(**kwargs):
...   print(kwargs)
... 
>>> func2()
{}
>>> func2(name='tom', age=20)
{'name': 'tom', 'age': 20}

>>> def func3(*args, **kwargs):
...   print(args)
...   print(kwargs)
... 
>>> func3('tom', 'jerry', dep='ops', sex='male')
('tom', 'jerry')
{'dep': 'ops', 'sex': 'male'}
```

- 调用函数时，在参数前加`*`或`**`表示将对象拆开

```python
>>> def add(x, y):
...   return x + y
... 
>>> nums = [10, 8]
>>> add(nums[0], nums[1])
18
>>> add(*nums)  # nums列表将拆成两个参数传给函数
18
>>> nums2 = {'x': 5, 'y': 3}
>>> add(**nums2)  # nums2被拆解成x=5, y=3传给函数
8
>>> nums3 = {'a': 5, 'b': 3}
>>> add(**nums3)  # 拆成a=5, b=3。Error，因为函数的参数没有a和b
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: add() got an unexpected keyword argument 'a'
```

## 匿名函数

- 匿名函数通过lambda定义
- 一个完整的lambda“语句”代表了一个表达式，这个表达式的定义体必须和声明放在同一行

```python
>>> def add(x, y):
...   return x + y
... 
>>> add(10, 20)
30

# lambda后面的x和y是参数。x + y的结果是返回值，不需要使用return
>>> myadd = lambda x, y: x + y
>>> myadd(10, 5)
15
```

#### filter函数

- 用于过滤数据。
- 它接受两个参数。第一个参数是函数，第二个参数是序列对象
- 第一个函数它接受一个参数，返回值必须是真或假。
- filter函数将会把序列对象的每个值交给第一个函数过滤，返回真的保留，假的过滤掉

```python
from random import randint

def func1(x):
    # 整数求余，返回值只有1或0。1为真，0为假
    return x % 2

if __name__ == '__main__':
    nums = [randint(1, 100) for i in range(10)]
    result1 = filter(func1, nums)
    result2 = filter(lambda x: x % 2, nums)
    print(nums)
    print(list(result1))
    print(list(result2))
```

#### map函数

- map函数用于加工数据
- 它接受两个参数。第一个参数是函数，第二个参数是序列对象
- map将序列对象中的每个值传递给第一个参数，将加工的结果保存下来

```python
from random import randint

def func1(x):
    return x + 100

if __name__ == '__main__':
    nums = [randint(1, 100) for i in range(10)]
    result1 = map(func1, nums)
    result2 = map(lambda x: x + 100, nums)
    print(nums)
    print(list(result1))
    print(list(result2))
```

## 变量作用域

- 在函数外定义的变量是全局变量，自它定义开始的地方到程序结束，一直可见可用

```python
>>> x = 10
>>> def func1():
...   print(x)
... 
>>> func1()
10
```

- 在函数内定义的变量是局部变量，只能在函数内使用。不同函数，可以拥有相同名称的变量，但是它们之间没有关系。

````python
>>> def func2():
...   a = 100
...   print(a)
... 
>>> func2()
100
>>> print(a)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'a' is not defined
````

- 全局和局部如果有相同名称的变量，局部变量将会遮盖住全局变量。

```python
>>> def func3():
...   x = 'hello world!'
...   print(x)
... 
>>> func3()
hello world!
>>> print(x)
10
```

- 如果希望在函数内改变全局变量的值，可以使用global关键字

```python
>>> def func4():
...   global x
...   x = 'how are you?'
...   print(x)
... 
>>> func4()
how are you?
>>> print(x)
how are you?
```

## 偏函数

- 通过functools中的partial改造现有函数，将现有函数的一部分参数固定下来，生成新的函数

```python
>>> from functools import partial
>>> def add(a, b, c, d, e):
...   return a + b + c + d + e
... 
>>> add(10, 20, 30, 40, 1)
101
>>> add(10, 20, 30, 40, 3)
103
>>> add(10, 20, 30, 40, 5)
105
# 改造add函数，将前4个参数固定下来。生成新的函数起名为myadd
>>> myadd = partial(add, 10, 20, 30, 40)
>>> myadd(5)
105
>>> myadd(8)
108
```

